/*  Функция банковского округления числа с проверкой на максимальное значние мантиссы.
    Это алгоритм округления величин до целых чисел, при котором числа,
    равноудаленные от двух ближайших целых чисел, округляются до ближайшего
    четного целого числа. равноудаленные это занчит 0.5-> 0, 1.5->2, 2,5->2 3,5->4
    Другие десятичные дроби округляются, как и следовало ожидать, — от 0,4 до 0,
    от 0,6 до 1, от 1,4 до 1, от 1,6 до 2 и т. д. Только числа x,5 получают
    «особую» обработку.

    Функция получает на вход строку, которую необходимо округлить и проверить,
    и знак числа.
    Подразумевается, что строка представляет собой результат каких-то математических
    функций и у неё может быть как слишком большая целая часть, так и дробная.
    Знак подаётся в виде двух возможных значений: POSITIVE = 0, NEGATIVE = 1, которые
    прописаны в заголовочном файле

    Если строка после округления помещается в мантиссу, то функция возвращает 0.
    Если число больше максимально-возможного значения, то возвращается 1.
    Если число больше максимально-возможного значения и у него отр.знак, то возвр. 2

    Если число дробное и не помещается в мантиссу, то округляется дробная часть
    до допустимых пределов

    ПРИМЕРЫ:
        1) 0.0000000000000000000000000000123 состоит из 31 значащих знаков
        (0 в целой части не считается). После округления до максимального порядка в
        28 знаков отбрасываются последние 3 знака и результат получается 0. 
        Число слишком мало, функция вернёт 0.
        
        2) 79228162514264337593543950335.56738974 состоит из 38 значащих цифр.
        Округляются дробная часть, которая не помещается в мантиссу и получается
        79228162514264337593543950336. Это число больше максимального decimal.
        Функция вернёт 1, если число положительное или 2, если отрицательное.

        3) 7.92281625142643375935439503350293 состоит из 33 значащих цифрю
        После округления части, которая не помещается в мантиссу, получается
        7.9228162514264337593543950335. Это число помещается в мантиссу.
        Функция вернёт 0
*/

#include "./s21_decimal.h"


int compare_str(char *temp, int sign); // Сравнение строки temp с эталоном
int my_round(char *str, int sign);  // Округление
int zero_check(char *str, int result);  // Проверка числа на ноль после округления

int bank_round(char *str, int sign) {
    int result = 0;
    char temp[BUF] = {'\0'};
    // Сначала определяем количество знаков перед запятой
    int int_part = (int)strlen(str) - digits_aft_dot(str);
    // И количество знаков после запятой
    int float_part = digits_aft_dot(str);
    // Если целочисленная часть больше 29 знаков, проверяем знак и присваиваем код возвр
    if (int_part > 29) {
        if (sign == 0)
            result = 1;
        else if (sign == 1)
            result = 2;
    // Если число из 29 знаков и float_part == 0, то проверяем с эталоном и копируем
    // в temp
    } else if (int_part == 29 && float_part == 0) {
        result = compare_str(str, sign);
        strcpy(temp, str);
    } else {
        // Удаляем точку
        remove_dot(str, temp);
        // И округляем число
        result = my_round(temp, sign);
    }
    // Если в ходе округления число 9 в целой части округлилось до 10, то увеличиваем
    // счётчик целой части, для корректного возврата точки
    if (temp[0] != str[0])
        int_part++;
    int i = 0;
    char temp2[BUF] = {'\0'};
    // Копируем целочисленную часть
    for (; i < int_part; i++) {
        temp2[i] = temp[i];
    }
    // Это флаг остатка. Ноль, если в дробной части есть что-то кроме нулей
    int zero_flag = 0;  
    // Проверяю остаток числа на нули
    for (int j = i; j < (int)strlen(temp); j++) {
        if (temp[j] != '0')
            zero_flag = 1;
    }
    // Если есть дробная часть, то ставлю точку и копирую остальную часть массива
    if (zero_flag == 1) {
        temp2[i] = '.';
        i++;
        for (; i <= (int)strlen(temp); i++) {
            temp2[i] = temp[i - 1];
        }
    }
    // Копирую результат в str через предварительное обнуление массива
    strcpy(temp, temp2);
    memset(str, '\0', BUF);
    strcpy(str, temp);

    return result;
}

int my_round(char *str, int sign) {
    int result = 0;
    char temp[BUF] = {'\0'};
    temp[0] = '1';  // Число которое мы будем прибавлять к str для округления
    size_t last_pos = 29; // Максимальное количество цифр в str
    // Если первые 29 символов в str больше эталона, то сокращаем строку на 1 элемент
    if (compare_str(str, sign) == 1)
        last_pos--;
    int max_dec_flag = 0;
    // Если число из 29 знаков, сверяем с максимальным значением decimal
    // Если дробную часть можно сократить, то порядковый номер последнего элемента
    // уменьшается
    if (strlen(str) == last_pos) {
        max_dec_flag = compare_str(str, sign);
        if (max_dec_flag != 0) {
            last_pos--;
        }
    }
    if (strlen(str) > last_pos) {
        if (str[last_pos] == '5') {
            if (((str[last_pos - 1] - '0') % 2) == 0) {
                // Если 28 элемент чётный (счёт с 0), то значение отбрасывается
                // Завершаем строку
                str[last_pos] = '\0';
            }
            else {
                str[last_pos] = '\0';
                revers(str, (int)strlen(str));
                summ_two_string(str, temp, str);
                revers(str, (int)strlen(str));
            }
        } else if (str[last_pos] < '5') {
            str[last_pos] = '\0';  // Зануляем последний элемент при отбрасывании остатка
        } else if (str[last_pos] > '5') {
            // Перезаписываем все элементы массива после last_pos знака
            for (size_t i = last_pos; i < BUF; i++) {
                str[i] = '\0';
            }
            revers(str, (int)strlen(str));
            summ_two_string(str, temp, str);
            revers(str, (int)strlen(str));
        }
    }
    // Округлённое число ещё раз проверяем с эталоном
    result = compare_str(str, sign);
    // Проверяем, состоит ли число только из нулей
    result = zero_check(str, result);

    return result;
}

// Посимвольно проверяем строку с максимальным decimal.
// Если число такое же, то идём на следующую итерацию.
// Если число меньше, чем значение эталона, то завершаем цикл
// Если число больше, то в зависимости от знака ставим LARGE или SMALL

int compare_str(char *temp, int sign) {
    if (strlen(temp) < 29)
        return 0;
    int result = 0;
    char *max_decimal = MAX_DECIMAL_STR;
    int length = (int)strlen(max_decimal);
    for (int i = 0; i < length; i++) {
        if (temp[i] == max_decimal[i])
            continue;
        else if (temp[i] < max_decimal[i]) {
            result = SUCCESS;
            break;
        }
        else if (temp[i] > max_decimal[i]) {
            if (sign == 0)
                result = LARGE;
            else if (sign == 1) {
                result = SMALL;
            }
            break;
        }
    }
    return result;
}

// Функция проверяет строку на что-то помимо нулей. 
// Если строка состоит только из нулей (это уже округлённое значение), то 
// возвращаем 2.

int zero_check(char *str, int result) {
    int zero_flag = 0;
    char temp[BUF] = {'\0'};
    remove_dot(str, temp);
    for (int i = 0; i < (int)strlen(temp); i++) {
        if (temp[i] != '0') {
            zero_flag = 1;
        }
    }
    if (zero_flag == 0) {
        result = 2;
    }
    return result;
}
